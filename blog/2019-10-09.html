<!DOCTYPE html>
<html lang="en">

    <!-- Ibis Cybernetics Blog Index -->

    <!-- Head begins here -->
    <head>
        <meta charset="utf-8" />
        <meta name="description" content="Ibis Cybernetics Corporation" />
        <meta name="keywords" content="software,c,php,artwork,pixel art,robotics,cybernetics" />
        <meta name="robots" content="index,follow" />
        <meta name="author" content="Robert Bisewski" />

        <!-- css -->
        <link rel="stylesheet" href="ibis_cybernetics_blog.css">

        <!-- favicon -->
        <link href="../ibis.ico" rel="shortcut icon" type="image/x-icon" />

        <!-- assign a title to this page -->
        <title>Cyberia Blog - Ibis Cybernetics Corporation</title>
    </head>

    <!-- Body begins here -->
    <body>

        <!-- Blog entry content goes here -->
        <div class="centre_content">

            <a href="index.html">&larr; back</a>

            <h1>
               2019-10-09: the mathematics of game programming
            </h1>

            <br>

            <p>
               Game development and game engines tend to require a lot of
               parallel processing power in order to run any significantly
               complex rendered scenes. This is a consequence of the fact
               that the building blocks consist of simple triangles, along
               with a variety of other systems, such as particle effects
               and in-game physics.
            </p>

            <p>
               Before we begin, there is an essential concept that will be
               discussed, which while not being mathematical in nature,
               serves as the base for most games. Specifically, the concept
               of the "game loop" which often consist of:
            </p>

            <p class="grey_monospace_code">
                1. process input
                <br>
                2. update game
                <br>
                3. render
            </p>

            <p>
               This basic flow continues infinitely and allows the developer
               to handle whatever input it received from the player, then
               update the game world with whatever variables are at play, then
               render the sprites or textures or models or physics, and
               finally start over at the beginning.
            </p>

            <p>
               Now, in games vector arithmetic is very common, typically for
               determining line location and length, or the relative location
               of a point for a given set of points. For vectors that consist
               of a single vertex of the style of (x,y,z), the simplest
               operations of addition and subtraction apply like so:
            </p>

            <p class="grey_monospace_code">
               (1,2,3) + (0,2,2) = (1,4,5)
               <br>
               (1,2,3) - (0,2,2) = (1,0,1)
            </p>

            <p>
               For multiple line vectors, basic knowledge of geometry and
               trigonometry of the angles apply. Some simple visualizations:
            </p>

            <img src="2019-10-09/01.png" />

            <p>
               Vector dot product values are useful for many things, such as
               calculating diffuse lighting or player position relative to
               another character. Specifically, a vector dot product is a
               mathematical operation on two vectors, which returns a number.
               Formulaically this is...
            </p>

            <p class="grey_monospace_code">
                dot product = u . v
            </p>

            <p>
               A good way to visualize this is as follows:
            </p>

            <img src="2019-10-09/02.png" />

            <p>
               Vector cross products are also operations on two vectors,
               wherein the result is a third vector which is perpendicular to
               the first two and has a length that is an average of both
               lengths. These are quite useful for a number of applications,
               notably collision detections; e.g. between the player and the
               wall, the cross product vector would be the "adjusted" path
               that the player would take due to collision with a wall.
               Formulaically this is...
            </p>

            <p class="grey_monospace_code">
                cross product = u x v
            </p>

            <p>
               This can be visualized as follows, where the blue line is the
               cross product:
            </p>

            <img src="2019-10-09/03.png" />

            <p>
               Matrix math is related to the vector arithmetic, with some of
               the more interesting applications being related to HLSL or GLSL
               shaders. In addition they can be used for handling bounding
               boxes or bounding sphere since subtracting matrixes of the
               length or radius makes multidimensional concerns simpler. Some
               typical examples of the variety used in game development might
               be as below:
            </p>

            <img src="2019-10-09/04.png" />

            <p>
               When it comes to the concept of collisions,
               <a href="https://en.wikipedia.org/wiki/Minimum_bounding_box">bounding boxes</a>
               are an important concept since they can define the minimum and
               maximum extent of an object, and thus, allows for the creation
               of walls that can block the path of a game character from
               moving in that direction.
            </p>

            <p>
               For a rectangle, the bounding box would be as follows, where
               lx is the x-coord of the largest dimension and wy is the
               y-coord of the smallest dimension:
            </p>

            <p class="grey_monospace_code">
                bounding box of a rectangle, length min = [lx1 - lx2, ly1 - ly2]
                <br>
                bounding box of a rectangle, length max = [lx1 + lx2, ly1 + ly2]
                <br>
                bounding box of a rectangle, width min &nbsp;= [wx1 - wx2, wy1 - wy2]
                <br>
                bounding box of a rectangle, width max &nbsp;= [wx1 + wx2, wy1 + wy2]
            </p>

            <p>
               For a circle, the bounding box would as follows, where cx is
               x-coord of the centre of the circle, and r is the radius:
            </p>

            <p class="grey_monospace_code">
                bounding box of a circle, min = [cx - r, cy - r]
                <br>
                bounding box of a circle, max = [cx + r, cy + r]
            </p>

            <p>
               For a sphere, the bounding box would be the below:
            </p>

            <p class="grey_monospace_code">
                bounding box of a sphere, min = [cx - r, cy - r, cz - r]
                <br>
                bounding box of a sphere, max = [cx + r, cy + r, cz + r]
            </p>

            <p>
               A related concept to the bounding box is the
               <a href="https://en.wikipedia.org/wiki/Bounding_sphere">bounding sphere</a>
               which is similar but using spheres as a cheap way of reducing
               excessive surfaces to collide as an alternative to using boxes.
            </p>

            <br>
        </div>
    </body>
</html>
