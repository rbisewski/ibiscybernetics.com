<!DOCTYPE html>
<html lang="en">

    <!-- Ibis Cybernetics Blog Index -->

    <!-- Head begins here -->
    <head>
        <meta charset="utf-8" />
        <meta name="description" content="Ibis Cybernetics Corporation" />
        <meta name="keywords" content="software,c,php,artwork,pixel art,robotics,cybernetics" />
        <meta name="robots" content="index,follow" />
        <meta name="author" content="Robert Bisewski" />

        <!-- css -->
        <link rel="stylesheet" href="ibis_cybernetics_blog.css">

        <!-- favicon -->
        <link href="../ibis.ico" rel="shortcut icon" type="image/x-icon" />

        <!-- assign a title to this page -->
        <title>Cyberia Blog - Ibis Cybernetics Corporation</title>
    </head>

    <!-- Body begins here -->
    <body>

        <!-- Blog entry content goes here -->
        <div class="centre_content">

            <a href="index.html">&larr; back</a>

            <h1>
               2019-10-13: basic concepts of game design
            </h1>

            <br>

            <p>
               Modern game development relies on a number of basic design
               concepts and fundamental ideas in order for all of the
               features players expect to; textures, models, animations,
               audio, particle systems, and good enough performance to run
               on the current hardware.
            </p>

            <p>
               This blog post will mostly be a collection of notes that I
               found helpful when learning about the fundamentals of video
               games.
            </p>

            <p>
               Good game design is about the in-game systems, problem solving,
               player experience, and game loops that keep the player hooked.
            </p>
                
            <p>
               Quaternion is composed of four components, one in the real part, and the
               other three in the imaginary part. A quaternion is usually denoted as:
            </p>

            <p class="grey_monospace_code">
               q = w + xi + yj + zk
            </p>
                
            <p>
                Fundamental formula for Quaternions:
            </p>

            <p class="grey_monospace_code">
                i^2 = j^2 = k^2 = i * j * k = -1
            </p>
                
            <p>
               Game object orientation can be represented by axis-angles, with a mapping
               between an axis-angle pair and a unit quaternion
            </p>
                
            <p>
               Frame coherence is a measurement of how much your game scene changes across
               time steps. If the position and velocity of rigid bodies do not change a
               lot between two time steps, then these two frames have high frame coherence.
            </p>
                
            <p>
               Vertex shaders are a programmable Shader stage in the rendering pipeline
               that handles the processing of individual vertices. Typically they are
               used to perform transformations to post-projection space, for consumption
               by vertex post-processing.
            </p>
                
            <p>
               Rasterization is the process by which each individual primitive is broken
               down into discrete elements called fragments, based on the sample coverage
               of the primitive.
            </p>
                
            <p>
               Fragmentation shader is the Shader stage that will process a Fragment
               generated by the Rasterization into a set of colours and a single depth
               value.
            </p>
                
            <p>
               Timeslicing is a useful technique to improve the performance of batched
               algorithms. Consider using it for elements of the game, such as handling
               NPC or enemy decision logic, assuming the game features a lot of NPCs or
               monsters.
            </p>
                
            <p>
                During the game loop, you can account for a given object's
                velocity and position by adjusting for the change in time...
            </p>

            <p class="grey_monospace_code">
               Velocity += acceleration * delta Time
               <br>
               Position += velocity * delta Time
            </p>
                
            <p>
               Common degree-to-radian mapping:
            </p>

            <p class="grey_monospace_code">
                30 degrees == pi/6
                <br>
                45 degrees == pi/4
                <br>
                60 degrees == pi/3
                <br>
                90 degrees == pi/2
                <br>
                180 degrees == pi
            </p>
                
            <p>
               Spherical linear interpolation (slerp), where t is the
               interpolation parameter between 0 or 1.
            </p>

            <p class="grey_monospace_code">
                Slerp(q1,q2,t) = (sin((1-t) * omega) * q1) / sin(omega) + (sin(t * omega) * q2) / sin(omega)
                <br>
                Omega = cos-1(q1*q2)
            </p>
                
            <p>
                How to create a hovering motion:
            </p>

            <p class="grey_monospace_code">
                Vector3 hover = 
                <br>
                &nbsp;&nbsp;new Vector3
                <br>
                &nbsp;&nbsp;(
                <br>
                &nbsp;&nbsp;&nbsp;&nbsp;RadiusX * Mathf.Sin(RateX * Time.time + OffsetX), 
                <br>
                &nbsp;&nbsp;&nbsp;&nbsp;RadiusY * Mathf.Sin(RateY * Time.time + OffsetY), 
                <br>
                &nbsp;&nbsp;&nbsp;&nbsp;RadiusZ * Mathf.Sin(RateZ * Time.time + OffsetZ)
                <br>
                &nbsp;&nbsp;);
                <br>
                <br>
                obj.transform.position = basePosition + hover;
            </p>
                
            <p>
                Deadlock is when two threads are stuck (i.e. locked), each
                waiting for the other to finish.
            </p>
                
            <p>
                Race conditions occur when two or more threads try to access
                shared data and then try to change it at the same time. This
                can be addressed by using immutables (consts) more and add
                additional logic (mutex) to ensure proper isolation or
                exclusion.
            </p>
                
            <p>
               Heaps are specialized tree-based data structure which is
               satisfies the heap property, specifically it serves as a
               priority queue.
            </p>
                
            <p>
               Keep in mind the different paradigms between Atomic vs Mutex;
               atomics allows for lockless concurrency, while mutex means
               mutually exclusive and involves locks.
            </p>

            <br>
        </div>
    </body>
</html>
